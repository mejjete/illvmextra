# Partial visualization of C++ Draft N4860 

digraph CppISO_IEC_JTC1_SC22_WG21_N4890_EBNF_Diagram {
    rankdir=LR;
    node [shape=box];



    # [gram.key] ------------------------------------------------------------------

    "typedef-name" -> "identifier";
    "typedef-name" -> "simple-template-id"; 



    # [gram.lex] ------------------------------------------------------------------

    "hex-quad" -> "hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit";

    unchnm1[label=<\u hex-quad<BR/><BR/>
\U hex-quad hex-quad>];
    "universal-character-name" -> unchnm1;

    pptok1[label=<header-name<BR/><BR/>
import-keyword<BR/><BR/>
module-keyword<BR/><BR/>
export-keyword<BR/><BR/>
identifier<BR/><BR/>
pp-number<BR/><BR/>
character-literal<BR/><BR/>
user-defined-character-literal<BR/><BR/>
string-literal<BR/><BR/>
user-defined-string-literal<BR/><BR/>
preprocessing-op-or-punc<BR/><BR/>
each non-white-space character that cannot be one of the above>];
    "preprocessing-token" -> pptok1;

    tk1[label=<identifier<BR/><BR/>
keyword<BR/><BR/>
literal<BR/><BR/>
operator-or-punctuator>];
    "token" -> tk1;

    hdname1[label=<h-char-sequence<BR/><BR/>
&quot;q-char-sequence&quot;>];
    "header-name" -> hdname1;

    hchseq1[label=<h-char<BR/><BR/>
h-char-sequence h-char>];
    "h-char-sequence" -> hchseq1;

    "h-char" -> "any member of the source character set except new-line and >";

    qchseq1[label=<q-char<BR/><BR/>
q-char-sequence q-char>];
    "q-char-sequence" -> qchseq1;

    "q-char" -> "any member of the source character set except new-line and ";

    ppnum1[label=<digit<BR/><BR/>
. digit<BR/><BR/>
pp-number digit<BR/><BR/>
pp-number identifier-nondigit<BR/><BR/>
pp-number ’ digit<BR/><BR/>
pp-number ’ nondigit<BR/><BR/>
pp-number e sign<BR/><BR/>
pp-number E sign<BR/><BR/>
pp-number p sign<BR/><BR/>
pp-number P sign<BR/><BR/>
pp-number .>];
    "pp-number" -> ppnum1;

    ident1[label=<identifier-nondigit<BR/><BR/>
identifier identifier-nondigit<BR/><BR/>
identifier digit>];
    "identifier" ->ident1;

    identdig1[label=<nondigit<BR/><BR/>
universal-character-name>];
    "identifier-nondigit" -> identdig1;
    
    ltrl1[label=<integer-literal<BR/><BR/>
character-literal<BR/><BR/>
floating-point-literal<BR/><BR/>
string-literal<BR/><BR/>
boolean-literal<BR/><BR/>
pointer-literal<BR/><BR/>
user-defined-literal>];
    "literal" -> ltrl1;

    intglit1[label=<binary-literal integer-suffix<SUB>opt</SUB><BR/><BR/>
octal-literal integer-suffix<SUB>opt</SUB>
decimal-literal integer-suffix<SUB>opt</SUB>
hexadecimal-literal integer-suffix<SUB>opt</SUB>>];
    "integer-literal" -> intglit1;
    
    bnlit1[label=<0b binary-digit<BR/><BR/>
0B binary-digit<BR/><BR/>
binary-literal ’<SUB>opt</SUB> binary-digit>];
    "binary-literal" -> bnlit1;
    
    octlit1[label=<0<BR/><BR/>
octal-literal ’<SUB>opt</SUB> octal-digit>];
    "octal-literal" -> octlit1;

    declit1[label=<nonzero-digit
decimal-literal ’<BR/><BR/> digit>];
    "decimal-literal" -> declit1;
 
    "hexadecimal-literal" -> "hexadecimal-prefix hexadecimal-digit-sequence";

    "binary-digit" -> "one of [ 1 0] ";
    
    "octal-digit" -> "one of [ 0 1 2 3 4 5 6 7 ]";

    intsuf1[label=<unsigned-suffix long-suffix<SUB>opt</SUB><BR/><BR/>
unsigned-suffix long-long-suffix<SUB>opt</SUB><BR/><BR/>
long-suffix unsigned-suffix<SUB>opt</SUB><BR/><BR/>
long-long-suffix unsigned-suffix<SUB>opt</SUB>>];
    "integer-suffix" -> intsuf1;

    fplit1[label=<decimal-floating-point-literal<BR/><BR/>
hexadecimal-floating-point-literal>];
    "floating-point-literal" -> fplit1;

    decfplit1[label=<fractional-constant exponent-part<SUB>opt</SUB> floating-point-suffix<SUB>opt</SUB><BR/><BR/>
digit-sequence exponent-part floating-point-suffix<SUB>opt</SUB>>];
    "decimal-floating-point-literal" -> decfplit1;

    hexfplit1[label=<hexadecimal-prefix hexadecimal-fractional-constant binary-exponent-part floating-point-suffix<SUB>opt</SUB><BR/><BR/>
hexadecimal-prefix hexadecimal-digit-sequence binary-exponent-part floating-point-suffix<SUB>opt</SUB>>];
    "hexadecimal-floating-point-literal" -> hexfplit1;

    fracconst1[label=<digit-sequence<SUB>opt</SUB> . digit-sequence<BR/><BR/>
digit-sequence .>];
    "fractional-constant" -> fracconst1;

    hexfraconst1[label=<hexadecimal-digit-sequence<SUB>opt</SUB> . hexadecimal-digit-sequence<BR/><BR/>
hexadecimal-digit-sequence .>];
    "hexadecimal-fractional-constant" -> hexfraconst1;

    expar1[label=<e sign<SUB>opt</SUB> digit-sequence<BR/><BR/>
E sign<SUB>opt</SUB> digit-sequence>];
    "exponent-part" -> expar1;

    binexpar1[label=<p sign<SUB>opt</SUB> digit-sequence<BR/><BR/>
P sign<SUB>opt</SUB> digit-sequence>];
    "binary-exponent-part" -> binexpar1;

    strlit1[label=<encoding-prefix<SUB>opt</SUB> " s-char-sequence<SUB>opt</SUB> "<BR/><BR/>
encoding-prefix<SUB>opt</SUB> R raw-string>];
    "string-literal" -> strlit1;

    schseq1[label=<s-char<BR/><BR/>
s-char-sequence s-char>];
    "s-char-sequence" -> schseq1;

    schst1[label=<any member of the basic source character set except the double-quote ", backslash \, or new-line character<BR/><BR/>
escape-sequence<BR/><BR/>
universal-character-name>];
    "s-char" -> schst1;

    rwstr1[label=<d-char-sequence<SUB>opt</SUB> ( r-char-sequence<SUB>opt</SUB> ) d-char-sequence<SUB>opt</SUB>>];
    "raw-string" -> rwstr1;

    rchseq1[label=<r-char<BR/><BR/>
r-char-sequence r-char>];
    "r-char-sequence" -> rchseq1;

    rchr1[label=<any member of the source character set, except a right parenthesis ) followed by<BR/><BR/>
the initial d-char-sequence (which may be empty) followed by a double quote ".>];
    "r-char" -> rchr1;

    dchseq1[label=<d-char<BR/><BR/>
d-char-sequence d-char>];
    "d-char-sequence" -> dchseq1;

    dchr1[label=<any member of the basic source character set except:<BR/><BR/>
space, the left parenthesis (, the right parenthesis ), the backslash \, and the control characters<BR/><BR/>
representing horizontal tab, vertical tab, form feed, and newline.>];
    "d-char" -> "dchr1";

    "pointer-literal" -> "nullptr";

    usrdeflit1[label=<user-defined-integer-literal<BR/><BR/>
user-defined-floating-point-literal<BR/><BR/>
user-defined-string-literal<BR/><BR/>
user-defined-character-literal>];
    "user-defined-literal" -> usrdeflit1;

    usrdefintlit1[label=<decimal-literal ud-suffix<BR/><BR/>
octal-literal ud-suffix<BR/><BR/>
hexadecimal-literal ud-suffix<BR/><BR/>
binary-literal ud-suffix>];
    "user-defined-integer-literal" -> usrdefintlit1;
    
    usrdeffplit1[label=<fractional-constant exponent-part<SUB>opt</SUB> ud-suffix<BR/><BR/>
digit-sequence exponent-part ud-suffix<BR/><BR/>
hexadecimal-prefix hexadecimal-fractional-constant binary-exponent-part ud-suffix<BR/><BR/>
hexadecimal-prefix hexadecimal-digit-sequence binary-exponent-part ud-suffix>];
    "user-defined-floating-point-literal" -> usrdeffplit1;
    
    "user-defined-string-literal" -> "string-literal ud-suffix";

    "user-defined-character-literal" -> "character-literal ud-suffix";

    "ud-suffix" -> "identifier";



    # [gram.expr] ------------------------------------------------------------------

    primexpr1[label=<literal<BR/><BR/>
this<BR/><BR/>
( expression )<BR/><BR/>
id-expression<BR/><BR/>
lambda-expression<BR/><BR/>
fold-expression<BR/><BR/>
requires-expression>];
    "primary-expression" -> primexpr1;

    idexpr1[label=<unqualified-id<BR/><BR/>
qualified-id>];
    "id-expression" -> idexpr1;

    unqualexpr1[label=<identifier<BR/><BR/>
operator-function-id<BR/><BR/>
conversion-function-id<BR/><BR/>
literal-operator-id<BR/><BR/>
~ type-name<BR/><BR/>
~ decltype-specifier<BR/><BR/>
template-id>];
    "unqualified-id" -> unqualexpr1;

    qualid1[label=<nested-name-specifier template<SUB><SUB>opt</SUB></SUB> unqualified-id>];
    "qualified-id" -> qualid1;

    nestnmspec1[label=<::
type-name ::<BR/><BR/>
namespace-name ::<BR/><BR/>
decltype-specifier ::<BR/><BR/>
nested-name-specifier identifier ::<BR/><BR/>
nested-name-specifier template<SUB><SUB>opt</SUB></SUB> simple-template-id ::>];
    "nested-name-specifier" -> nestnmspec1;
    
    lmexpr1 [label=<lambda-introducer lambda-declarator<SUB>opt</SUB> compound-statement<BR/><BR/>
lambda-introducer &lt; template-parameter-list &gt; requires-clause<SUB>opt</SUB> lambda-declarator<SUB>opt</SUB> compound-statement>];
    "lambda-expression" -> lmexpr1;
    
    lmintr1[label=<[ lambda-capture<SUB>opt</SUB> ]>];
    "lambda-introducer" -> lmintr1;

    lmdecl1[label=<( parameter-declaration-clause ) decl-specifier-seq<SUB>opt</SUB><BR/><BR/>
noexcept-specifier<SUB>opt</SUB> attribute-specifier-seq<SUB>opt</SUB> trailing-return-type<SUB>opt</SUB> requires-clause<SUB>opt</SUB>>];
    "lambda-declarator" -> lmdecl1;

    lmcap1[label=<capture-default<BR/><BR/>
capture-list<BR/><BR/>
capture-default , capture-list>];
    "lambda-capture" -> lmcap1;

    "capture-default";



    # [stmt.pre] ------------------------------------------------------------------

    statement1[label=<attribute-specifier-seq<SUB>opt</SUB> try-block>]
    statement2[label=<attribute-specifier-seq<SUB>opt</SUB> expression-statement>]
    statement3[label=<attribute-specifier-seq<SUB>opt</SUB> compound-statement>]
    statement4[label=<attribute-specifier-seq<SUB>opt</SUB> selection-statement>]
    statement5[label=<attribute-specifier-seq<SUB>opt</SUB> iteration-statement>]
    statement6[label=<attribute-specifier-seq<SUB>opt</SUB> jump-statement>]

    statement -> "labeled-statement"
    statement -> statement2;
    statement -> statement3;
    statement -> statement4;
    statement -> statement5;
    statement -> statement6;
    statement -> "declaration-statement";
    statement -> statement1;

    "init-statement" -> "expression-statement";
    "init-statement" -> "simple-declaration";

    condition1[label=<attribute-specifier-seq<SUB>opt</SUB> decl-specifier-seq declarator brace-or-equal-initializer>]
    "condition" -> "expression";
    "condition" -> condition1;

    labeledstm1[label=<attribute-specifier-seq<SUB>opt</SUB> identifier : statement<BR/><BR/>
attribute-specifier-seq<SUB>opt</SUB> case constant-expression : statement<BR/><BR/>
attribute-specifier-seq<SUB>opt</SUB> default : statement>]
    "labeled-statement" -> labeledstm1;

    expressionstm1[label=<expression<SUB>opt</SUB>>];
    "expression-statement" -> expressionstm1;

    compoundstm1[label=<{ statement-seq<SUB>opt</SUB> } >];
    "compound-statement" -> compoundstm1;

    "statement-seq" -> statement;
    "statement-seq" -> "statement-seq statement"

    selectionstm1[label=<if constexpr<SUB>opt</SUB> ( init-statement<SUB>opt</SUB> condition ) statement<BR/><BR/>
if constexpr<SUB>opt</SUB>( init-statement<SUB>opt</SUB> condition ) statement else statement<BR/><BR/>
switch ( init-statement<SUB>opt</SUB> condition ) statement>];
    "selection-statement" -> selectionstm1;



    # [stmt.iter] ------------------------------------------------------------------

    iterationsmt1[label=<for ( init-statement condition<SUB>opt</SUB> ; expression<SUB>opt</SUB> ) statement<BR/><BR/>
for ( init-statement<SUB>opt</SUB> for-range-declaration : for-range-initializer ) statement<BR/><BR/>
while ( condition ) statement<BR/><BR/>
do statement while ( expression ) ;>];
    "iterator-statement" -> iterationsmt1;

    forrdecl1[label=<attribute-specifier-seq<SUB>opt</SUB> decl-specifier-seq declarator<BR/><BR/>
attribute-specifier-seq<SUB>opt</SUB> decl-specifier-seq ref-qualifier<SUB>opt</SUB> [ identifier-list ]>];
    "for-range-declaration" -> forrdecl1;

    "for-range-initializer" -> "expr-or-braced-init-list"



    # [dcl.pre] ------------------------------------------------------------------

    "declaration-seq" -> declaration;
    "declaration-seq" -> "declaration-seq declaration"

    declaration -> "block-declaration";
    declaration -> "nodeclspec-function-declaration";
    declaration -> "function-definition";
    declaration -> "template-declaration";
    declaration -> "deduction-guide";
    declaration -> "explicit-instantiation";
    declaration -> "explicit-specialization";
    declaration -> "export-declaration";
    declaration -> "linkage-specification";
    declaration -> "namespace-definition";
    declaration -> "empty-declaration";
    declaration -> "attribute-declaration";
    declaration -> "module-import-declaration";

    "block-declaration" -> "simple-declaration";
    "block-declaration" -> "asm-declaration";
    "block-declaration" -> "namespace-alias-definition";
    "block-declaration" -> "using-declaration";
    "block-declaration" -> "using-enum-declaration";
    "block-declaration" -> "using-directive";
    "block-declaration" -> "static_assert-declaration";
    "block-declaration" -> "alias-declaration";
    "block-declaration" -> "opaque-enum-declaration";

    nodesclspecfucdecl1[label=<attribute-specifier-seq<SUB>opt</SUB> declarator ;>];
    "nodeclspec-function-declaration" -> nodesclspecfucdecl1;

    aliasdecl1[label=<using identifier attribute-specifier-seq<SUB>opt</SUB> = defining-type-id ;>]
    "alias-declaration" -> aliasdecl1;

    simpldecl1[label=<decl-specifier-seq init-declarator-list<SUB>opt</SUB> ;<BR/><BR/>
attribute-specifier-seq decl-specifier-seq init-declarator-list ;<BR/><BR/>
attribute-specifier-seq<SUB>opt</SUB> decl-specifier-seq ref-qualifier<SUB>opt</SUB> [ identifier-list ] initializer ;>];
    "simple-declaration" -> simpldecl1;

    statasrtdecl1[label=<static_assert ( constant-expression ) <BR/><BR/>
static_assert ( constant-expression , string-literal ) ;;>]
    "static_assert-declaration" -> statasrtdecl1;
    
    "empty-declaration" -> ";";

    "attribute-declaration" -> "attribute-specifier-seq ;";



    # [dcl.spec] ------------------------------------------------------------------

    "decl-specifier" -> "storage-class-specifier";
    "decl-specifier" -> "defining-type-specifier";
    "decl-specifier" -> "function-specifier";
    "decl-specifier" -> friend;
    "decl-specifier" -> typedef;
    "decl-specifier" -> constexpr;
    "decl-specifier" -> consteval;
    "decl-specifier" -> constinit;
    "decl-specifier" -> inline;

    declspecseq1[label=<decl-specifier attribute-specifier-seq<SUB>opt</SUB><BR/><BR/>
decl-specifier decl-specifier-seq>];
    "decl-specifier-seq" -> "declspecseq1";

    "function-specifier" -> virtual;
    "function-specifier" -> "explicit-specifier";

    "explicit-specifier" -> "explicit ( constant-expression )";
    "explicit-specifier" -> "explicit";

    "typedef-name" -> identifier;
    "typedef-name" -> "simple-template-id";



    # [dcl.type] ------------------------------------------------------------------

    "type-specifier" -> "simple-type-specifier";
    "type-specifier" -> "elaborated-type-specifier";
    "type-specifier" -> "typename-specifier";
    "type-specifier" -> "cv-qualifier";

    typespecseq1[label=<type-specifier attribute-specifier-seq<SUB>opt</SUB><BR/><BR/>
type-specifier type-specifier-seq>];
    "type-specifier-seq" -> typespecseq1;

    "defining-type-specifier" -> "type-specifier";
    "defining-type-specifier" -> "class-specifier";
    "defining-type-specifier" -> "enum-specifier";

    definingtypespecseq1[label=<defining-type-specifier attribute-specifier-seq<SUB>opt</SUB><BR/><BR/>
defining-type-specifier defining-type-specifier-seq<BR/><BR/>>];
    "defining-type-specifier-seq" -> definingtypespecseq1;
    
    "type-name" -> "class-name";
    "type-name" -> "enum-name";
    "type-name" -> "typedef-name";

    elaboratedtpspec1[label=<class-key attribute-specifier-seq<SUB>opt</SUB> nested-name-specifier<SUB>opt</SUB> identifier;<BR/><BR/>
class-key nested-name-specifier template<SUB>opt</SUB> simple-template-id<BR/><BR/>
class-key simple-template-id>];
    "elaborated-type-specifier" -> elaboratedtpspec1;
    "elaborated-type-specifier" -> "elaborated-enum-specifier";

    elaboratedenspec1[label=<enum nested-name-specifier<SUB>opt</SUB> identifier>];
    "elaborated-enum-specifier" -> elaboratedenspec1;

    "decltype-specifier" -> "decltype ( expression )";

    placeholdtpspec1[label=<type-constraint<SUB>opt</SUB> auto<BR/><BR/>
type-constraint<SUB>opt</SUB> decltype ( auto )>];
    "placeholder-type-specifier" -> placeholdtpspec1;



    # [dcl.decl] ------------------------------------------------------------------

    "init-declarator-list" -> "init-declarator";
    "init-declarator-list" -> "init-declarator-list , init-declarator";

    initdecl1[label=<declarator initializer<SUB>opt</SUB><BR/><BR/>
declarator requires-clause>];

    "init-declarator" -> initdecl1;

    "declarator" -> "ptr-declarator";
    "declarator" -> "noptr-declarator parameters-and-qualifiers trailing-return-type";

    "ptr-declarator" -> "noptr-declarator";
    "ptr-declarator" -> "ptr-operator ptr-declarator";

    noptrdecl1[label=<declarator-id attribute-specifier-seq<SUB>opt</SUB><BR/><BR/>
noptr-declarator [ constant-expression<SUB>opt</SUB> ] attribute-specifier-seq<SUB>opt</SUB><BR/><BR/>
noptr-declarator parameters-and-qualifiers<BR/><BR/>
( ptr-declarator )>];
    "noptr-declarator" -> noptrdecl1;

    parametersqual1[label=<( parameter-declaration-clause ) cv-qualifier-seq<SUB>opt</SUB><BR/><BR/>
ref-qualifier<SUB>opt</SUB> noexcept-specifier<SUB>opt</SUB> attribute-specifier-seq<SUB>opt</SUB>>];

    "parameters-and-qualifiers" -> parametersqual1;

    "trailing-return-type" -> "-> type-id";

    ptrop1[label=<* attribute-specifier-seq<SUB>opt</SUB> cv-qualifier-seq<SUB>opt</SUB><BR/><BR/>
&amp; attribute-specifier-seq<SUB>opt</SUB><BR/><BR/>
&amp;&amp; attribute-specifier-seq<SUB>opt</SUB><BR/><BR/>
nested-name-specifier * attribute-specifier-seq<SUB>opt</SUB> cv-qualifier-seq<SUB>opt</SUB>>];
    "ptr-operator" -> ptrop1; 

    cvqualseq1[label=<cv-qualifier cv-qualifier-seq<SUB>opt</SUB>>];
    "cv-qualifier-seq" -> cvqualseq1;

    "cv-qualifier" -> "const";
    "cv-qualifier" -> "volatile";

    refqual1[label=<. . .&amp;<SUB>opt</SUB><BR/><BR/>&amp;&amp;>];
    "ref-qualifier" -> refqual1;

    declid1[label=<id-expression>];
    "declarator-id" -> declid1;



    # [dcl.name] ------------------------------------------------------------------
    
    typeid1[label=<type-specifier-seq abstract-declarator<SUB>opt</SUB>>]
    "type-id" -> typeid1;

    deftypeid1[label=<defining-type-specifier-seq abstract-declarator<SUB>opt</SUB>>]
    "defining-type-id" -> deftypeid1;

    abstrdecl1[label=<noptr-abstract-declarator<SUB>opt</SUB> parameters-and-qualifiers trailing-return-type>]
    "abstract-declarator" -> "ptr-abstract-declarator";
    "abstract-declarator" -> abstrdecl1;
    "abstract-declarator" -> "abstract-pack-declarator";

    ptrabstrdecl1[label=<ptr-operator ptr-abstract-declarator<SUB>opt</SUB>>];
    "ptr-abstract-declarator" -> "noptr-abstract-declarator"
    "ptr-abstract-declarator" -> ptrabstrdecl1;

    noptrabstdecl1[label=<noptr-abstract-declarator<SUB>opt</SUB> parameters-and-qualifiers<BR/><BR/>
noptr-abstract-declarator<SUB>opt</SUB> [ constant-expression<SUB>opt</SUB> ] attribute-specifier-seqo<SUB>opt</SUB><BR/><BR/>
( ptr-abstract-declarator )>];
    "noptr-abstract-declarator" -> noptrabstdecl1;

    "abstract-pack-declarator" -> "noptr-abstract-pack-declarator"; 
    "abstract-pack-declarator" -> "ptr-operator abstract-pack-declarator";

    noptrabspackdecl1[label=<noptr-abstract-pack-declarator [ constant-expression<SUB>opt</SUB> ] attribute-specifier-seq<SUB>opt</SUB><BR/><BR/>
noptr-abstract-pack-declarator parameters-and-qualifiers<BR/><BR/>
. . .>];
    "noptr-abstract-pack-declarator" -> noptrabspackdecl1;



    # [dcl.fct] ------------------------------------------------------------------

    parameterdeclclause1[label=<parameter-declaration-list<SUB>opt</SUB> . . .<SUB>opt</SUB><BR/><BR/>
parameter-declaration-list , . . .>];
    "parameter-declaration-clause" -> parameterdeclclause1;

    pardecl1[label=<attribute-specifier-seq<SUB>opt</SUB> decl-specifier-seq declarator<BR/><BR/>
attribute-specifier-seq<SUB>opt</SUB> decl-specifier-seq declarator = initializer-clause<BR/><BR/>
attribute-specifier-seq<SUB>opt</SUB> decl-specifier-seq abstract-declarator<SUB>opt</SUB><BR/><BR/>
attribute-specifier-seq<SUB>opt</SUB> decl-specifier-seq abstract-declarator<SUB>opt</SUB> = initializer-clause>];
    "parameter-declaration" -> pardecl1;



    # [dcl.init] ------------------------------------------------------------------

    "initializer" -> "brace-or-equal-initializer"
    "initializer" -> "( expression-list )";

    "brace-or-equal-initializer" -> "= initializer-clause"; 
    "brace-or-equal-initializer" -> "braced-init-list";

    "initializer-clause" -> "assignment-expression";
    "initializer-clause" -> "braced-init-list";

    brinitl1[label=<{ initializer-list ,<SUB>opt</SUB> }<BR/><BR/>
{ designated-initializer-list ,<SUB>opt</SUB> }<BR/><BR/>
{}>];

    "braced-init-list" -> brinitl1;

    initl1[label=<initializer-clause . . .<SUB>opt</SUB><BR/><BR/>
initializer-list , initializer-clause . . .<SUB>opt</SUB>>];
    "initializer-list" -> initl1;

    "designated-initializer-list" -> "designated-initializer-clause"; 
    "designated-initializer-list" -> "designated-initializer-list , designated-initializer-clause";

    "designated-initializer-clause" -> "designator brace-or-equal-initializer";

    "designator" -> ". identifier";

    "expr-or-braced-init-list" -> "expression";
    "expr-or-braced-init-list" -> "braced-init-list";



    # [dcl.fct.def] ------------------------------------------------------------------
    
    funcdecl1[label=<attribute-specifier-seq<SUB>opt</SUB> decl-specifier-seq<SUB>opt</SUB> declarator virt-specifier-seq<SUB>opt</SUB> function-body<BR/><BR/>
attribute-specifier-seq<SUB>opt</SUB> decl-specifier-seq<SUB>opt</SUB> declarator requires-clause function-body>];
    "function-definition" -> funcdecl1;

    funcbd1[label=<ctor-initializer<SUB>opt</SUB> compound-statement>];
    "function-body" -> funcbd1;
    "function-body" -> "function-try-block";
    "function-body" -> "= default ;";
    "function-body" -> "= delete ;";



    # [dcl.enum] ------------------------------------------------------------------
    
    "enum-name" -> "identifier";
    enumspec1[label=<enum-head { enumerator-list<SUB>opt</SUB> }>];

    "enum-specifier" -> enumspec1;
    "enum-specifier" -> "enum-head { enumerator-list , }";

    enumh1[label=<enum-key attribute-specifier-seqopt enum-head-name<SUB>opt</SUB> enum-base<SUB>opt</SUB>>];
    "enum-head" -> enumh1;

    enumname1[label=<nested-name-specifier<SUB>opt</SUB> identifier>];
    "enum-head-name" -> enumname1;

    opaqueendecl1[label=<enum-key attribute-specifier-seq<SUB>opt</SUB> enum-head-name enum-base<SUB>opt</SUB> ;">];
    "opaque-enum-declaration" -> opaqueendecl1;

    "enum-key" -> "enum";
    "enum-key" -> "enum class";
    "enum-key" -> "enum struct";

    "enum-base" -> "type-specifier-seq";

    "enumerator-list" -> "enumerator-definition";
    "enumerator-list" -> "enumerator-list , enumerator-definition";

    "enumerator-definition" -> "enumerator";
    "enumerator-definition" -> "enumerator = constant-expression";

    enumer1[label=<identifier attribute-specifier-seq<SUB>opt</SUB>>];
    enumerator -> enumer1;



    # [namespace.def] ------------------------------------------------------------------

    "namespace-name" -> "identifier";
    "namespace-name" -> "namespace-alias";

    "namespace-definition" -> "named-namespace-definition";
    "namespace-definition" -> "unnamed-namespace-definition";
    "namespace-definition" -> "nested-namespace-definition";

    namespacedef1[label=<inline<SUB>opt</SUB> namespace attribute-specifier-seq<SUB>opt</SUB> identifier { namespace-body }>];
    "named-namespace-definition" -> namespacedef1;

    unnamenamdef1[label=<inline<SUB>opt</SUB> namespace attribute-specifier-seq<SUB>opt</SUB> { namespace-body }>]
    "unnamed-namespace-definition" -> unnamenamdef1;

    nsnamenamdef1[label=<namespace enclosing-namespace-specifier :: inline<SUB>opt</SUB> identifier { namespace-body }>];
    "nested-namespace-definition" -> nsnamenamdef1;

    encnamespec1[label=<nested-namespace-definition :>];
    "enclosing-namespace-specifier" -> "identifier";
    "enclosing-namespace-specifier" -> encnamespec1;

    nsbody1[label=<declaration-seq<SUB>opt</SUB>>];
    "namespace-body" -> nsbody1;



    # [namespace.alias] ------------------------------------------------------------------

    "namespace-alias" -> "identifier;"
    "namespace-alias-definition" -> "namespace identifier = qualified-namespace-specifier ;"

    qualnsspec1[label=<nested-name-specifier<SUB>opt</SUB> namespace-name>]
    "qualified-namespace-specifier" -> qualnsspec1;

    usdirns1[label=<attribute-specifier-seq<SUB>opt</SUB> using namespace nested-name-specifier<SUB>opt</SUB> namespace-name ;>];
    "using-directive" -> usdirns1;

    "using-declaration" -> "using using-declarator-list ;";

    usdeclist1[label=<using-declarator . . .<SUB>opt</SUB><BR/><BR/>
using-declarator-list , using-declarator . . .<SUB>opt</SUB>>];
    "using-declarator-list" -> usdeclist1;

    linkspec1[label=<extern string-literal { declaration-seq<SUB>opt</SUB> }<BR/><BR/>
extern string-literal declaration>];
    "linkage-specification" -> linkspec1;



    # [dcl.attr] ------------------------------------------------------------------

    attrspecseq1[label=<attribute-specifier-seq<SUB><SUB>opt</SUB></SUB> attribute-specifier>];
    "attribute-specifier-seq" -> attrspecseq1;

    attrspec1[label=<[ [ attribute-using-prefix<SUB>opt</SUB> attribute-list ] ]>];
    "attribute-specifier" -> attrspec1;
    "attribute-specifier" -> "alignment-specifier";

    allignspec1[label=<alignas ( type-id . . .<SUB>opt</SUB> )<BR/><BR/>
alignas ( constant-expression . . .<SUB>opt</SUB> )>];
    "alignment-specifier" -> allignspec1;

    "attribute-using-prefix" -> "using attribute-namespace";

    attrl1[label=<attribute-list<SUB>opt</SUB><BR/><BR/>
attribute-list , attribute<SUB>opt</SUB>
attribute-list , attribute . . .<BR/><BR/>
attribute . . .>];
    "attribute-list" -> attrl1; 

    attr1[label=<attribute-token attribute-argument-clause<SUB>opt</SUB>>];
    "attribute" -> attr1;

    "attribute-token" -> identifier;
    "attribute-token" -> "attribute-scoped-token";

    "attribute-scoped-token" -> "attribute-namespace :: identifier";

    "attribute-namespace" -> "identifier";

    attrargcl1[label=<( balanced-token-seq<SUB>opt</SUB> )>];
    "attribute-argument-clause" -> attrargcl1;

    "balanced-token-seq" -> "balanced-token";
    "balanced-token-seq" -> "balanced-token-seq balanced-token";

    baltok1[label=<( balanced-token-seq<SUB>opt</SUB> )<BR/><BR/>
[ balanced-token-seq<SUB>opt</SUB> ]<BR/><BR/>
{ balanced-token-seq<SUB>opt</SUB> }<BR/><BR/>
any token other than a parenthesis, a bracket, or a brace>];
    "balanced-token" -> baltok1;



    # [module.init] ------------------------------------------------------------------

    moddecl1[label=<export-keyword<SUB>opt</SUB> module-keyword module-name module-partition<SUB>opt</SUB> attribute-specifier-seq<SUB>opt</SUB> ;>];
    "module-declaration" -> moddecl1;

    modname1[label=<module-name-qualifier<SUB>opt</SUB> identifier>];
    "module-name" -> modname1;

    modpart1[label=<: module-name-qualifier<SUB>opt</SUB> identifier>];
    "module-partition" -> modpart1;

    "module-name-qualifier" -> "identifier .";
    "module-name-qualifier" -> "module-name-qualifier identifier .";

    exdecl1[label=<export { declaration-seq<SUB>opt</SUB> }<BR/><BR/>
export declaration<BR/><BR/>
export-keyword module-import-declaration>];
    "export-declaration" -> exdecl1;

    imprtdecl1[label=<import-keyword module-name attribute-specifier-seq<SUB>opt</SUB> ;<BR/><BR/>
import-keyword module-partition attribute-specifier-seq<SUB>opt</SUB> ;<BR/><BR/>
import-keyword header-name attribute-specifier-seq<SUB>opt</SUB> ;>];
    "module-import-declaration" -> imprtdecl1;

    glmodfrag1[label=<module-keyword ; declaration-seq<SUB>opt</SUB>>]
    "global-module-fragment" -> glmodfrag1;

    privmodfrag1[label=<module-keyword : private ; declaration-seq<SUB>opt</SUB>>];
    "private-module-fragment" -> privmodfrag1;

    

    # [class.pre] ------------------------------------------------------------------

    "class-name" -> "identifier";
    "class-name" -> "simple-template-id";

    classpec1[label=<class-head { member-specification<SUB>opt</SUB> }>];
    "class-specifier" -> classpec1;

    classhd1[label=<class-key attribute-specifier-seq<SUB>opt</SUB> class-head-name class-virt-specifier<SUB>opt</SUB> base-clause<SUB>opt</SUB><BR/><BR/>
class-key attribute-specifier-seq<SUB>opt</SUB> base-clause<SUB>opt</SUB>>];
    "class-head" -> classhd1;

    classhdnm1[label=<nested-name-specifier<SUB>opt</SUB> class-name>];
    "class-head-name" -> classhdnm1;

    "class-virt-specifier" -> "final";

    "class-key" -> "class";
    "class-key" -> "struct";
    "class-key" -> "union";

    memspec1[label=<member-declaration member-specification<SUB>opt</SUB><BR/><BR/>
access-specifier : member-specification<SUB>opt</SUB>>];
    "member-specification" -> memspec1;

    memdecl1[label=<attribute-specifier-seq<SUB>opt</SUB> decl-specifier-seq<SUB>opt</SUB> member-declarator-list<SUB>opt</SUB> ;>];
    "member-declaration" -> memdecl1;
    "member-declaration" -> "function-definition";
    "member-declaration" -> "using-declaration";
    "member-declaration" -> "using-enum-declaration";
    "member-declaration" -> "static_assert-declaration";
    "member-declaration" -> "template-declaration";
    "member-declaration" -> "explicit-specialization";
    "member-declaration" -> "deduction-guide";
    "member-declaration" -> "alias-declaration";
    "member-declaration" -> "opaque-enum-declaration";
    "member-declaration" -> "empty-declaration";

    "member-declarator-list" -> "member-declarator";
    "member-declarator-list" -> "member-declarator-list , member-declarator";

    memdecl1[label=<declarator virt-specifier-seq<SUB>opt</SUB> pure-specifier<SUB>opt</SUB><BR/><BR/>
declarator brace-or-equal-initializer<SUB>opt</SUB><BR/><BR/>
identifier<SUB>opt</SUB> attribute-specifier-seq<SUB>opt</SUB> : constant-expression brace-or-equal-initializer<SUB>opt</SUB><BR/><BR/>
declarator requires-clause>];
    "member-declarator" -> memdecl1;

    "virt-specifier-seq" -> "virt-specifier";
    "virt-specifier-seq" -> "virt-specifier-seq virt-specifier";

    "virt-specifier" -> "override";
    "virt-specifier" -> "final";

    "pure-specifier" -> "= 0";

    "conversion-function-id" -> "operator conversion-type-id";

    convtpid1[label=<type-specifier-seq conversion-declarator<SUB>opt</SUB>>];
    "conversion-type-id" -> convtpid1;

    convdecl1[label=<ptr-operator conversion-declarator<SUB>opt</SUB>>];
    "conversion-declarator" -> convdecl1;



    # [class.derived] ------------------------------------------------------------------

    "base-clause" -> "base-specifier-list";

    basespecl1[label=<base-specifier . . .<SUB>opt</SUB><BR/><BR/>
base-specifier-list , base-specifier . . .<SUB>opt</SUB>>];
    "base-specifier-list" -> basespecl1;

    basespec1[label=<attribute-specifier-seq<SUB>opt</SUB> class-or-decltype<BR/><BR/>
attribute-specifier-seq<SUB>opt</SUB> virtual access-specifier<SUB>opt</SUB> class-or-decltype<BR/><BR/>
attribute-specifier-seq<SUB>opt</SUB> access-specifier virtual<SUB>opt</SUB> class-or-decltype>];
    "base-specifier" -> basespec1;

    clasordecl1[label=<nested-name-specifier<SUB>opt</SUB> type-name&gt;
nested-name-specifier template simple-template-id<BR/><BR/>
decltype-specifie>];
    "class-or-decltype" -> clasordecl1;

    "access-specifier" -> "private";
    "access-specifier" -> "protected";
    "access-specifier" -> "public";



    # [class.base.init] ------------------------------------------------------------------

    "ctor-initializer" -> ": mem-initializer-list";

    meminitlist1[label=<mem-initializer . . .<SUB>opt</SUB><BR/><BR/>
mem-initializer-list , mem-initializer . . .<SUB>opt</SUB>>];
    "mem-initializer-list" -> meminitlist1;

    meminitl1[label=<mem-initializer-id ( expression-list<SUB>opt</SUB> )<BR/><BR/>
mem-initializer-id braced-init-list>];
    "mem-initializer" -> meminitlist1;

    "mem-initializer-id" -> "class-or-decltype";
    "mem-initializer-id" -> "identifier";



    # [over.call.func] ------------------------------------------------------------------

    pstexpr1[label=<postfix-expression . id-expression<BR/><BR/>
postfix-expression -&gt; id-expression<BR/><BR/>
primary-expression>];

    "postfix-expression" -> pstexpr1;

    "operator-function-id" -> "operator operator";

    oper1[label=<new<BR/><BR/>
delete<BR/><BR/>
new[]<BR/><BR/>
delete[]<BR/><BR/>
co_await<BR/><BR/>
()<BR/><BR/>
[]<BR/><BR/>
&rarr;<BR/><BR/>
&rarr;*<BR/><BR/>
~<BR/><BR/>
!<BR/><BR/>
+<BR/><BR/>
-<BR/><BR/>
*<BR/><BR/>
/<BR/><BR/>
%<BR/><BR/>
^<BR/><BR/>
&amp;<BR/><BR/>
|<BR/><BR/>
=<BR/><BR/>
+=<BR/><BR/>
-=<BR/><BR/>
*=<BR/><BR/>
/=<BR/><BR/>
%=<BR/><BR/>
^=<BR/><BR/>
&amp;=<BR/><BR/>
|=<BR/><BR/>
==<BR/><BR/>
!=<BR/><BR/>
&lt;<BR/><BR/>
&gt;<BR/><BR/>
&lt;=<BR/><BR/>
&gt;=<BR/><BR/>
&lt;=&gt;<BR/><BR/>
&amp;&amp;<BR/><BR/>
||<BR/><BR/>
&lt;&lt;<BR/><BR/>
&gt;&gt;<BR/><BR/>
&lt;&lt;=<BR/><BR/>
&gt;&gt;=<BR/><BR/>
++<BR/><BR/>
--<BR/><BR/>
,>];
"operator" -> oper1;



    # [over.literal] ------------------------------------------------------------------

    liopid1[label=<operator string-literal identifier<BR/><BR/>
operator user-defined-string-literal>];
    "literal-operator-id" -> liopid1;



    # [temp.pre] ------------------------------------------------------------------

    tempdecl1[label=<template-head declaration<BR/><BR/>template-head concept-definition>];
    "template-declaration" -> tempdecl1;

    tmplh1[label=<template &lt; template-parameter-list &gt; requires-clause<SUB>opt</SUB>>];
    "template-head" -> tmplh1;

    tmplparl1[label=<template-parameter<BR/><BR/>template-parameter-list , template-parameter>];
    "template-parameter-list" -> tmplparl1;

    "requires-clause" -> "requires constraint-logical-or-expression";

    constlogorexp1[label=<constraint-logical-and-expression<BR/><BR/>constraint-logical-or-expression || constraint-logical-and-expression>];
    "constraint-logical-or-expression" -> constlogorexp1;

    constlogandexp1[label=<primary-expression<BR/><BR/>constraint-logical-and-expression &amp;&amp; primary-expression>];
    "constraint-logical-or-expression" -> constlogandexp1;



    # [temp.param] ------------------------------------------------------------------

    temppar1[label=<type-parameter<BR/><BR/>parameter-declaration>];
    "template-parameter" -> temppar1;

    typepar1[label=<type-parameter-key . . .<SUB>opt</SUB> identifier<SUB>opt</SUB><BR/><BR/>
type-parameter-key identifier<SUB>opt</SUB> = type-id<BR/><BR/>
type-constraint . . .<SUB>opt</SUB> identifier<SUB>opt</SUB><BR/><BR/>
type-constraint identifier<SUB>opt</SUB> = type-id<BR/><BR/>
template-head type-parameter-key . . .<SUB>opt</SUB> identifier<SUB>opt</SUB><BR/><BR/>
template-head type-parameter-key identifier<SUB>opt</SUB> = id-expression>];
    "type-parameter" -> typepar1;

    "type-parameter-key" -> "class";
    "type-parameter-key" -> "typename";

    tpcstr1[label=<nested-name-specifier<SUB>opt</SUB> concept-name<BR/><BR/>nested-name-specifier<SUB>opt</SUB> concept-name &lt; template-argument-list<SUB>opt</SUB> &gt;>];
    "type-constraint" -> tpcstr1;



    # [temp.names] ------------------------------------------------------------------

    smtempid1[label=<template-name &lt; template-argument-list<SUB>opt</SUB> &gt;>];
    "simple-template-id" -> smtempid1;

    tmpid1[label=<simple-template-id<BR/><BR/>operator-function-id &lt; template-argument-list<SUB>opt</SUB> &gt;<BR/><BR/>literal-operator-id &lt; template-argument-list<SUB>opt</SUB> &gt;>];
    "template-id" -> tmpid1;

    "template-name" -> "identifier";

    tmpargl1[label=<template-argument . . .<SUB>opt</SUB><BR/><BR/>template-argument-list , template-argument . . .<SUB>opt</SUB>>];
    "template-argument-list" -> tmpargl1;

    "template-argument" -> "constant-expression";
    "template-argument" -> "type-id";
    "template-argument" -> "id-expression";

    dedgd1[label=<explicit-specifier<SUB>opt</SUB> template-name ( parameter-declaration-clause ) -&gt; simple-template-id ;>];
    "deduction-guide" -> dedgd1;



    # [temp.concept] ------------------------------------------------------------------

    "concept-definition" -> "concept concept-name = constraint-expression ;";

    "concept-name" -> "identifier";

    explinstant1[label=<extern<SUB>opt</SUB> template declaration>];
    "explicit-instantiation" -> explinstant1;



    # [except.pre] ------------------------------------------------------------------

    "try-block" -> "try compound-statement handler-seq";

    functrblk1[label=<try ctor-initializer<SUB>opt</SUB> compound-statement handler-seq>];
    "function-try-block" -> functrblk1;

    hndseq1[label=<handler handler-seq<SUB>opt</SUB>>];
    "handler-seq" -> hndseq1;

    "handler" -> "catch ( exception-declaration ) compound-statement";

    excpdecl1[label=<attribute-specifier-seq<SUB>opt</SUB> type-specifier-seq declarator<BR/><BR/>attribute-specifier-seq<SUB>opt</SUB> type-specifier-seq abstract-declarator<SUB>opt</SUB><BR/><BR/>. . .>];
    "exception-declaration" -> excpdecl1;

    "noexcept-specifier" -> "noexcept ( constant-expression )";
    "noexcept-specifier" -> "noexcept";



    # [cpp.pre] ------------------------------------------------------------------
}
