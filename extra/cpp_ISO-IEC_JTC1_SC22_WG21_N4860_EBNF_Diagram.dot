# Partial visualization of C++ Draft N4860 

digraph CppISO_IEC_JTC1_SC22_WG21_N4890_EBNF_Diagram {
    rankdir=LR;
    node [shape=box];



    # [stmt.pre] ------------------------------------------------------------------

    statement1[label=<attribute-specifier-seq<SUB>opt</SUB> try-block>]
    statement2[label=<attribute-specifier-seq<SUB>opt</SUB> expression-statement>]
    statement3[label=<attribute-specifier-seq<SUB>opt</SUB> compound-statement>]
    statement4[label=<attribute-specifier-seq<SUB>opt</SUB> selection-statement>]
    statement5[label=<attribute-specifier-seq<SUB>opt</SUB> iteration-statement>]
    statement6[label=<attribute-specifier-seq<SUB>opt</SUB> jump-statement>]

    statement -> "labeled-statement"
    statement -> statement2;
    statement -> statement3;
    statement -> statement4;
    statement -> statement5;
    statement -> statement6;
    statement -> "declaration-statement";
    statement -> statement1;

    "init-statement" -> "expression-statement";
    "init-statement" -> "simple-declaration";

    condition1[label=<attribute-specifier-seq<SUB>opt</SUB> decl-specifier-seq declarator brace-or-equal-initializer>]
    "condition" -> "expression";
    "condition" -> condition1;

    labeledstm1[label=<attribute-specifier-seq<SUB>opt</SUB> identifier : statement<BR/><BR/>
attribute-specifier-seq<SUB>opt</SUB> case constant-expression : statement<BR/><BR/>
attribute-specifier-seq<SUB>opt</SUB> default : statement>]
    "labeled-statement" -> labeledstm1;

    expressionstm1[label=<expression<SUB>opt</SUB>>];
    "expression-statement" -> expressionstm1;

    compoundstm1[label=<{ statement-seq<SUB>opt</SUB> } >];
    "compound-statement" -> compoundstm1;

    "statement-seq" -> statement;
    "statement-seq" -> "statement-seq statement"

    selectionstm1[label=<if constexpr<SUB>opt</SUB> ( init-statement<SUB>opt</SUB> condition ) statement<BR/><BR/>
if constexpr<SUB>opt</SUB>( init-statement<SUB>opt</SUB> condition ) statement else statement<BR/><BR/>
switch ( init-statement<SUB>opt</SUB> condition ) statement>];
    "selection-statement" -> selectionstm1;



    # [stmt.iter] ------------------------------------------------------------------

    iterationsmt1[label=<for ( init-statement condition<SUB>opt</SUB> ; expression<SUB>opt</SUB> ) statement<BR/><BR/>
for ( init-statement<SUB>opt</SUB> for-range-declaration : for-range-initializer ) statement<BR/><BR/>
while ( condition ) statement<BR/><BR/>
do statement while ( expression ) ;>];
    "iterator-statement" -> iterationsmt1;

    forrdecl1[label=<attribute-specifier-seq<SUB>opt</SUB> decl-specifier-seq declarator<BR/><BR/>
attribute-specifier-seq<SUB>opt</SUB> decl-specifier-seq ref-qualifier<SUB>opt</SUB> [ identifier-list ]>];
    "for-range-declaration" -> forrdecl1;

    "for-range-initializer" -> "expr-or-braced-init-list"



    # [dcl.pre] ------------------------------------------------------------------

    "declaration-seq" -> declaration;
    "declaration-seq" -> "declaration-seq declaration"

    declaration -> "block-declaration";
    declaration -> "nodeclspec-function-declaration";
    declaration -> "function-definition";
    declaration -> "template-declaration";
    declaration -> "deduction-guide";
    declaration -> "explicit-instantiation";
    declaration -> "explicit-specialization";
    declaration -> "export-declaration";
    declaration -> "linkage-specification";
    declaration -> "namespace-definition";
    declaration -> "empty-declaration";
    declaration -> "attribute-declaration";
    declaration -> "module-import-declaration";

    "block-declaration" -> "simple-declaration";
    "block-declaration" -> "asm-declaration";
    "block-declaration" -> "namespace-alias-definition";
    "block-declaration" -> "using-declaration";
    "block-declaration" -> "using-enum-declaration";
    "block-declaration" -> "using-directive";
    "block-declaration" -> "static_assert-declaration";
    "block-declaration" -> "alias-declaration";
    "block-declaration" -> "opaque-enum-declaration";

    nodesclspecfucdecl1[label=<attribute-specifier-seq<SUB>opt</SUB> declarator ;>];
    "nodeclspec-function-declaration" -> nodesclspecfucdecl1;

    aliasdecl1[label=<using identifier attribute-specifier-seq<SUB>opt</SUB> = defining-type-id ;>]
    "alias-declaration" -> aliasdecl1;

    simpldecl1[label=<decl-specifier-seq init-declarator-list<SUB>opt</SUB> ;<BR/><BR/>
attribute-specifier-seq decl-specifier-seq init-declarator-list ;<BR/><BR/>
attribute-specifier-seq<SUB>opt</SUB> decl-specifier-seq ref-qualifier<SUB>opt</SUB> [ identifier-list ] initializer ;>];
    "simple-declaration" -> simpldecl1;

    statasrtdecl1[label=<static_assert ( constant-expression ) <BR/><BR/>
static_assert ( constant-expression , string-literal ) ;;>]
    "static_assert-declaration" -> statasrtdecl1;
    
    "empty-declaration" -> ";";

    "attribute-declaration" -> "attribute-specifier-seq ;";



    # [dcl.spec] ------------------------------------------------------------------

    "decl-specifier" -> "storage-class-specifier";
    "decl-specifier" -> "defining-type-specifier";
    "decl-specifier" -> "function-specifier";
    "decl-specifier" -> friend;
    "decl-specifier" -> typedef;
    "decl-specifier" -> constexpr;
    "decl-specifier" -> consteval;
    "decl-specifier" -> constinit;
    "decl-specifier" -> inline;

    declspecseq1[label=<decl-specifier attribute-specifier-seq<SUB>opt</SUB><BR/><BR/>
decl-specifier decl-specifier-seq>];
    "decl-specifier-seq" -> "declspecseq1";

    "function-specifier" -> virtual;
    "function-specifier" -> "explicit-specifier";

    "explicit-specifier" -> "explicit ( constant-expression )";
    "explicit-specifier" -> "explicit";

    "typedef-name" -> identifier;
    "typedef-name" -> "simple-template-id";



    # [dcl.type] ------------------------------------------------------------------

    "type-specifier" -> "simple-type-specifier";
    "type-specifier" -> "elaborated-type-specifier";
    "type-specifier" -> "typename-specifier";
    "type-specifier" -> "cv-qualifier";

    typespecseq1[label=<type-specifier attribute-specifier-seq<SUB>opt</SUB><BR/><BR/>
type-specifier type-specifier-seq>];
    "type-specifier-seq" -> typespecseq1;

    "defining-type-specifier" -> "type-specifier";
    "defining-type-specifier" -> "class-specifier";
    "defining-type-specifier" -> "enum-specifier";

    definingtypespecseq1[label=<defining-type-specifier attribute-specifier-seq<SUB>opt</SUB><BR/><BR/>
defining-type-specifier defining-type-specifier-seq<BR/><BR/>>];
    "defining-type-specifier-seq" -> definingtypespecseq1;
    
    "type-name" -> "class-name";
    "type-name" -> "enum-name";
    "type-name" -> "typedef-name";

    elaboratedtpspec1[label=<class-key attribute-specifier-seq<SUB>opt</SUB> nested-name-specifier<SUB>opt</SUB> identifier;<BR/><BR/>
class-key nested-name-specifier template<SUB>opt</SUB> simple-template-id<BR/><BR/>
class-key simple-template-id>];
    "elaborated-type-specifier" -> elaboratedtpspec1;
    "elaborated-type-specifier" -> "elaborated-enum-specifier";

    elaboratedenspec1[label=<enum nested-name-specifier<SUB>opt</SUB> identifier>];
    "elaborated-enum-specifier" -> elaboratedenspec1;

    "decltype-specifier" -> "decltype ( expression )";

    placeholdtpspec1[label=<type-constraint<SUB>opt</SUB> auto<BR/><BR/>
type-constraint<SUB>opt</SUB> decltype ( auto )>];
    "placeholder-type-specifier" -> placeholdtpspec1;



    # [dcl.decl] ------------------------------------------------------------------

    "init-declarator-list" -> "init-declarator";
    "init-declarator-list" -> "init-declarator-list , init-declarator";

    initdecl1[label=<declarator initializer<SUB>opt</SUB><BR/><BR/>
declarator requires-clause>];

    "init-declarator" -> initdecl1;

    "declarator" -> "ptr-declarator";
    "declarator" -> "noptr-declarator parameters-and-qualifiers trailing-return-type";

    "ptr-declarator" -> "noptr-declarator";
    "ptr-declarator" -> "ptr-operator ptr-declarator";

    noptrdecl1[label=<declarator-id attribute-specifier-seq<SUB>opt</SUB><BR/><BR/>
noptr-declarator [ constant-expression<SUB>opt</SUB> ] attribute-specifier-seq<SUB>opt</SUB><BR/><BR/>
noptr-declarator parameters-and-qualifiers<BR/><BR/>
( ptr-declarator )>];
    "noptr-declarator" -> noptrdecl1;

    parametersqual1[label=<( parameter-declaration-clause ) cv-qualifier-seq<SUB>opt</SUB><BR/><BR/>
ref-qualifier<SUB>opt</SUB> noexcept-specifier<SUB>opt</SUB> attribute-specifier-seq<SUB>opt</SUB>>];

    "parameters-and-qualifiers" -> parametersqual1;

    "trailing-return-type" -> "-> type-id";

    ptrop1[label=<* attribute-specifier-seq<SUB>opt</SUB> cv-qualifier-seq<SUB>opt</SUB><BR/><BR/>
&amp; attribute-specifier-seq<SUB>opt</SUB><BR/><BR/>
&amp;&amp; attribute-specifier-seq<SUB>opt</SUB><BR/><BR/>
nested-name-specifier * attribute-specifier-seq<SUB>opt</SUB> cv-qualifier-seq<SUB>opt</SUB>>];
    "ptr-operator" -> ptrop1; 

    cvqualseq1[label=<cv-qualifier cv-qualifier-seq<SUB>opt</SUB>>];
    "cv-qualifier-seq" -> cvqualseq1;

    "cv-qualifier" -> "const";
    "cv-qualifier" -> "volatile";

    refqual1[label=<. . .&amp;<SUB>opt</SUB><BR/><BR/>&amp;&amp;>];
    "ref-qualifier" -> refqual1;

    declid1[label=<id-expression>];
    "declarator-id" -> declid1;



    # [dcl.name] ------------------------------------------------------------------
    
    typeid1[label=<type-specifier-seq abstract-declarator<SUB>opt</SUB>>]
    "type-id" -> typeid1;

    deftypeid1[label=<defining-type-specifier-seq abstract-declarator<SUB>opt</SUB>>]
    "defining-type-id" -> deftypeid1;

    abstrdecl1[label=<noptr-abstract-declarator<SUB>opt</SUB> parameters-and-qualifiers trailing-return-type>]
    "abstract-declarator" -> "ptr-abstract-declarator";
    "abstract-declarator" -> abstrdecl1;
    "abstract-declarator" -> "abstract-pack-declarator";

    ptrabstrdecl1[label=<ptr-operator ptr-abstract-declaratoropt>];
    "ptr-abstract-declarator" -> "noptr-abstract-declarator"
    "ptr-abstract-declarator" -> ptrabstrdecl1;

    noptrabstdecl1[label=<noptr-abstract-declarator<SUB>opt</SUB> parameters-and-qualifiers<BR/><BR/>
noptr-abstract-declarator<SUB>opt</SUB> [ constant-expression<SUB>opt</SUB> ] attribute-specifier-seqo<SUB>opt</SUB><BR/><BR/>
( ptr-abstract-declarator )>];
    "noptr-abstract-declarator" -> noptrabstdecl1;

    "abstract-pack-declarator" -> "noptr-abstract-pack-declarator"; 
    "abstract-pack-declarator" -> "ptr-operator abstract-pack-declarator";

    noptrabspackdecl1[label=<noptr-abstract-pack-declarator [ constant-expressionopt ] attribute-specifier-seqopt<BR/><BR/>
noptr-abstract-pack-declarator parameters-and-qualifiers<BR/><BR/>
. . .>];
    "noptr-abstract-pack-declarator" -> noptrabspackdecl1;



    # [dcl.fct] ------------------------------------------------------------------

    parameterdeclclause1[label=<parameter-declaration-list<SUB>opt</SUB> . . .<SUB>opt</SUB><BR/><BR/>
parameter-declaration-list , . . .>];
    "parameter-declaration-clause" -> parameterdeclclause1;

    pardecl1[label=<attribute-specifier-seq<SUB>opt</SUB> decl-specifier-seq declarator<BR/><BR/>
attribute-specifier-seq<SUB>opt</SUB> decl-specifier-seq declarator = initializer-clause<BR/><BR/>
attribute-specifier-seq<SUB>opt</SUB> decl-specifier-seq abstract-declarator<SUB>opt</SUB><BR/><BR/>
attribute-specifier-seq<SUB>opt</SUB> decl-specifier-seq abstract-declarator<SUB>opt</SUB> = initializer-clause>];
    "parameter-declaration" -> pardecl1;



    # [dcl.init] ------------------------------------------------------------------

    "initializer" -> "brace-or-equal-initializer"
    "initializer" -> "( expression-list )";

    "brace-or-equal-initializer" -> "= initializer-clause"; 
    "brace-or-equal-initializer" -> "braced-init-list";

    "initializer-clause" -> "assignment-expression";
    "initializer-clause" -> "braced-init-list";

    brinitl1[label=<{ initializer-list ,<SUB>opt</SUB> }<BR/><BR/>
{ designated-initializer-list ,<SUB>opt</SUB> }<BR/><BR/>
{}>];

    "braced-init-list" -> brinitl1;

    initl1[label=<initializer-clause . . .<SUB>opt</SUB><BR/><BR/>
initializer-list , initializer-clause . . .<SUB>opt</SUB>>];
    "initializer-list" -> initl1;

    "designated-initializer-list" -> "designated-initializer-clause"; 
    "designated-initializer-list" -> "designated-initializer-list , designated-initializer-clause";

    "designated-initializer-clause" -> "designator brace-or-equal-initializer";

    "designator" -> ". identifier";

    "expr-or-braced-init-list" -> "expression";
    "expr-or-braced-init-list" -> "braced-init-list";



    # [dcl.fct.def] ------------------------------------------------------------------
    
    funcdecl1[label=<attribute-specifier-seq<SUB>opt</SUB> decl-specifier-seq<SUB>opt</SUB> declarator virt-specifier-seq<SUB>opt</SUB> function-body<BR/><BR/>
attribute-specifier-seq<SUB>opt</SUB> decl-specifier-seq<SUB>opt</SUB> declarator requires-clause function-body>];
    "function-definition" -> funcdecl1;

    funcbd1[label=<ctor-initializer<SUB>opt</SUB> compound-statement>];
    "function-body" -> funcbd1;
    "function-body" -> "function-try-block";
    "function-body" -> "= default ;";
    "function-body" -> "= delete ;";



    # [dcl.enum] ------------------------------------------------------------------
    
    "enum-name" -> "identifier";
    enumspec1[label=<enum-head { enumerator-list<SUB>opt</SUB> }>];

    "enum-specifier" -> enumspec1;
    "enum-specifier" -> "enum-head { enumerator-list , }";

    enumh1[label=<enum-key attribute-specifier-seqopt enum-head-name<SUB>opt</SUB> enum-base<SUB>opt</SUB>>];
    "enum-head" -> enumh1;

    enumname1[label=<nested-name-specifier<SUB>opt</SUB> identifier>];
    "enum-head-name" -> enumname1;

    opaqueendecl1[label=<enum-key attribute-specifier-seq<SUB>opt</SUB> enum-head-name enum-base<SUB>opt</SUB> ;">];
    "opaque-enum-declaration" -> opaqueendecl1;

    "enum-key" -> "enum";
    "enum-key" -> "enum class";
    "enum-key" -> "enum struct";

    "enum-base" -> "type-specifier-seq";

    "enumerator-list" -> "enumerator-definition";
    "enumerator-list" -> "enumerator-list , enumerator-definition";

    "enumerator-definition" -> "enumerator";
    "enumerator-definition" -> "enumerator = constant-expression";

    enumer1[label=<identifier attribute-specifier-seq<SUB>opt</SUB>>];
    enumerator -> enumer1;



    # [namespace.def] ------------------------------------------------------------------

    "namespace-name" -> "identifier";
    "namespace-name" -> "namespace-alias";

    "namespace-definition" -> "named-namespace-definition";
    "namespace-definition" -> "unnamed-namespace-definition";
    "namespace-definition" -> "nested-namespace-definition";

    namespacedef1[label=<inline<SUB>opt</SUB> namespace attribute-specifier-seq<SUB>opt</SUB> identifier { namespace-body }>];
    "named-namespace-definition" -> namespacedef1;

    unnamenamdef1[label=<inline<SUB>opt</SUB> namespace attribute-specifier-seq<SUB>opt</SUB> { namespace-body }>]
    "unnamed-namespace-definition" -> unnamenamdef1;

    nsnamenamdef1[label=<namespace enclosing-namespace-specifier :: inline<SUB>opt</SUB> identifier { namespace-body }>];
    "nested-namespace-definition" -> nsnamenamdef1;

    encnamespec1[label=<nested-namespace-definition :>];
    "enclosing-namespace-specifier" -> "identifier";
    "enclosing-namespace-specifier" -> encnamespec1;

    nsbody1[label=<declaration-seq<SUB>opt</SUB>>];
    "namespace-body" -> nsbody1;



    # [namespace.alias] ------------------------------------------------------------------

    "namespace-alias" -> "identifier;"
    "namespace-alias-definition" -> "namespace identifier = qualified-namespace-specifier ;"

    qualnsspec1[label=<nested-name-specifier<SUB>opt</SUB> namespace-name>]
    "qualified-namespace-specifier" -> qualnsspec1;

    usdirns1[label=<attribute-specifier-seq<SUB>opt</SUB> using namespace nested-name-specifier<SUB>opt</SUB> namespace-name ;>];
    "using-directive" -> usdirns1;

    "using-declaration" -> "using using-declarator-list ;";

    usdeclist1[label=<using-declarator . . .<SUB>opt</SUB><BR/><BR/>
using-declarator-list , using-declarator . . .<SUB>opt</SUB>>];
    "using-declarator-list" -> usdeclist1;

    linkspec1[label=<extern string-literal { declaration-seq<SUB>opt</SUB> }<BR/><BR/>
extern string-literal declaration>];
    "linkage-specification" -> linkspec1;



    # [dcl.attr] ------------------------------------------------------------------

    attrspecseq1[label=<attribute-specifier-seq<SUB><SUB>opt</SUB></SUB> attribute-specifier>];
    "attribute-specifier-seq" -> attrspecseq1;

    attrspec1[label=<[ [ attribute-using-prefix<SUB>opt</SUB> attribute-list ] ]>];
    "attribute-specifier" -> attrspec1;
    "attribute-specifier" -> "alignment-specifier";

    allignspec1[label=<alignas ( type-id . . .<SUB>opt</SUB> )<BR/><BR/>
alignas ( constant-expression . . .<SUB>opt</SUB> )>];
    "alignment-specifier" -> allignspec1;

    "attribute-using-prefix" -> "using attribute-namespace";

    attrl1[label=<attribute-list<SUB>opt</SUB><BR/><BR/>
attribute-list , attribute<SUB>opt</SUB>
attribute-list , attribute . . .<BR/><BR/>
attribute . . .>];
    "attribute-list" -> attrl1; 

    attr1[label=<attribute-token attribute-argument-clause<SUB>opt</SUB>>];
    "attribute" -> attr1;

    "attribute-token" -> identifier;
    "attribute-token" -> "attribute-scoped-token";

    "attribute-scoped-token" -> "attribute-namespace :: identifier";

    "attribute-namespace" -> "identifier";

    attrargcl1[label=<( balanced-token-seq<SUB>opt</SUB> )>];
    "attribute-argument-clause" -> attrargcl1;

    "balanced-token-seq" -> "balanced-token";
    "balanced-token-seq" -> "balanced-token-seq balanced-token";

    baltok1[label=<( balanced-token-seq<SUB>opt</SUB> )<BR/><BR/>
[ balanced-token-seq<SUB>opt</SUB> ]<BR/><BR/>
{ balanced-token-seq<SUB>opt</SUB> }<BR/><BR/>
any token other than a parenthesis, a bracket, or a brace>];
    "balanced-token" -> baltok1;



    # [module.init] ------------------------------------------------------------------

    moddecl1[label=<export-keyword<SUB>opt</SUB> module-keyword module-name module-partition<SUB>opt</SUB> attribute-specifier-seq<SUB>opt</SUB> ;>];
    "module-declaration" -> moddecl1;

    modname1[label=<module-name-qualifier<SUB>opt</SUB> identifier>];
    "module-name" -> modname1;

    modpart1[label=<: module-name-qualifier<SUB>opt</SUB> identifier>];
    "module-partition" -> modpart1;

    "module-name-qualifier" -> "identifier .";
    "module-name-qualifier" -> "module-name-qualifier identifier .";

    exdecl1[label=<export { declaration-seq<SUB>opt</SUB> }<BR/><BR/>
export declaration<BR/><BR/>
export-keyword module-import-declaration>];
    "export-declaration" -> exdecl1;

    imprtdecl1[label=<import-keyword module-name attribute-specifier-seq<SUB>opt</SUB> ;<BR/><BR/>
import-keyword module-partition attribute-specifier-seq<SUB>opt</SUB> ;<BR/><BR/>
import-keyword header-name attribute-specifier-seq<SUB>opt</SUB> ;>];
    "module-import-declaration" -> imprtdecl1;

    glmodfrag1[label=<module-keyword ; declaration-seq<SUB>opt</SUB>>]
    "global-module-fragment" -> glmodfrag1;

    privmodfrag1[label=<module-keyword : private ; declaration-seq<SUB>opt</SUB>>];
    "private-module-fragment" -> privmodfrag1;

    

    # [class.pre] ------------------------------------------------------------------

    "class-name" -> "identifier";
    "class-name" -> "simple-template-id";

    classpec1[label=<class-head { member-specification<SUB>opt</SUB> }>];
    "class-specifier" -> classpec1;

    classhd1[label=<class-key attribute-specifier-seq<SUB>opt</SUB> class-head-name class-virt-specifier<SUB>opt</SUB> base-clause<SUB>opt</SUB><BR/><BR/>
class-key attribute-specifier-seq<SUB>opt</SUB> base-clause<SUB>opt</SUB>>];
    "class-head" -> classhd1;

    classhdnm1[label=<nested-name-specifier<SUB>opt</SUB> class-name>];
    "class-head-name" -> classhdnm1;

    "class-virt-specifier" -> "final";

    "class-key" -> "class";
    "class-key" -> "struct";
    "class-key" -> "union";

    memspec1[label=<member-declaration member-specification<SUB>opt</SUB><BR/><BR/>
access-specifier : member-specification<SUB>opt</SUB>>];
    "member-specification" -> memspec1;

    memdecl1[label=<attribute-specifier-seq<SUB>opt</SUB> decl-specifier-seq<SUB>opt</SUB> member-declarator-list<SUB>opt</SUB> ;>];
    "member-declaration" -> memdecl1;
    "member-declaration" -> "function-definition";
    "member-declaration" -> "using-declaration";
    "member-declaration" -> "using-enum-declaration";
    "member-declaration" -> "static_assert-declaration";
    "member-declaration" -> "template-declaration";
    "member-declaration" -> "explicit-specialization";
    "member-declaration" -> "deduction-guide";
    "member-declaration" -> "alias-declaration";
    "member-declaration" -> "opaque-enum-declaration";
    "member-declaration" -> "empty-declaration";

    "member-declarator-list" -> "member-declarator";
    "member-declarator-list" -> "member-declarator-list , member-declarator";

    memdecl1[label=<declarator virt-specifier-seq<SUB>opt</SUB> pure-specifier<SUB>opt</SUB><BR/><BR/>
declarator brace-or-equal-initializer<SUB>opt</SUB><BR/><BR/>
identifier<SUB>opt</SUB> attribute-specifier-seq<SUB>opt</SUB> : constant-expression brace-or-equal-initializer<SUB>opt</SUB><BR/><BR/>
declarator requires-clause>];
    "member-declarator" -> memdecl1;

    "virt-specifier-seq" -> "virt-specifier";
    "virt-specifier-seq" -> "virt-specifier-seq virt-specifier";

    "virt-specifier" -> "override";
    "virt-specifier" -> "final";

    "pure-specifier" -> "= 0";

    "conversion-function-id" -> "operator conversion-type-id";

    convtpid1[label=<type-specifier-seq conversion-declarator<SUB>opt</SUB>>];
    "conversion-type-id" -> convtpid1;

    convdecl1[label=<ptr-operator conversion-declarator<SUB>opt</SUB>>];
    "conversion-declarator" -> convdecl1;



    # [class.derived] ------------------------------------------------------------------

    "base-clause" -> "base-specifier-list";

    basespecl1[label=<base-specifier . . .<SUB>opt</SUB><BR/><BR/>
base-specifier-list , base-specifier . . .<SUB>opt</SUB>>];
    "base-specifier-list" -> basespecl1;

    basespec1[label=<attribute-specifier-seq<SUB>opt</SUB> class-or-decltype<BR/><BR/>
attribute-specifier-seq<SUB>opt</SUB> virtual access-specifier<SUB>opt</SUB> class-or-decltype<BR/><BR/>
attribute-specifier-seq<SUB>opt</SUB> access-specifier virtual<SUB>opt</SUB> class-or-decltype>];
    "base-specifier" -> basespec1;

    clasordecl1[label=<nested-name-specifier<SUB>opt</SUB> type-name&gt;
nested-name-specifier template simple-template-id<BR/><BR/>
decltype-specifie>];
    "class-or-decltype" -> clasordecl1;

    "access-specifier" -> "private";
    "access-specifier" -> "protected";
    "access-specifier" -> "public";



    # [class.base.init] ------------------------------------------------------------------

    "ctor-initializer" -> ": mem-initializer-list";

    meminitlist1[label=<mem-initializer . . .<SUB>opt</SUB><BR/><BR/>
mem-initializer-list , mem-initializer . . .<SUB>opt</SUB>>];
    "mem-initializer-list" -> meminitlist1;

    meminitl1[label=<mem-initializer-id ( expression-list<SUB>opt</SUB> )<BR/><BR/>
mem-initializer-id braced-init-list>];
    "mem-initializer" -> meminitlist1;

    "mem-initializer-id" -> "class-or-decltype";
    "mem-initializer-id" -> "identifier";



    # [over.call.func] ------------------------------------------------------------------

    pstexpr1[label=<postfix-expression . id-expression<BR/><BR/>
postfix-expression -&gt; id-expression<BR/><BR/>
primary-expression>];

    "postfix-expression:" -> pstexpr1;

    "operator-function-id" -> "operator operator";

    oper1[label=<new<BR/><BR/>
delete<BR/><BR/>
new[]<BR/><BR/>
delete[]<BR/><BR/>
co_await<BR/><BR/>
()<BR/><BR/>
[]<BR/><BR/>
&rarr;<BR/><BR/>
&rarr;*<BR/><BR/>
~<BR/><BR/>
!<BR/><BR/>
+<BR/><BR/>
-<BR/><BR/>
*<BR/><BR/>
/<BR/><BR/>
%<BR/><BR/>
^<BR/><BR/>
&amp;<BR/><BR/>
|<BR/><BR/>
=<BR/><BR/>
+=<BR/><BR/>
-=<BR/><BR/>
*=<BR/><BR/>
/=<BR/><BR/>
%=<BR/><BR/>
^=<BR/><BR/>
&amp;=<BR/><BR/>
|=<BR/><BR/>
==<BR/><BR/>
!=<BR/><BR/>
&lt;<BR/><BR/>
&gt;<BR/><BR/>
&lt;=<BR/><BR/>
&gt;=<BR/><BR/>
&lt;=&gt;<BR/><BR/>
&amp;&amp;<BR/><BR/>
||<BR/><BR/>
&lt;&lt;<BR/><BR/>
&gt;&gt;<BR/><BR/>
&lt;&lt;=<BR/><BR/>
&gt;&gt;=<BR/><BR/>
++<BR/><BR/>
--<BR/><BR/>
,>];
"operator" -> oper1;



    # [over.literal] ------------------------------------------------------------------

    liopid1[lable=<operator string-literal identifier<BR/><BR/>
operator user-defined-string-literal>];
    "literal-operator-id" -> liopid1;



    # [temp.pre] ------------------------------------------------------------------

    tempdecl1[label=<template-head declaration<BR/><BR/>template-head concept-definition>];
    "template-declaration" -> tempdecl1;

    tmplh1[label=<template &lt; template-parameter-list &gt; requires-clause<SUB>opt</SUB>>];
    "template-head" -> tmplh1;

    tmplparl1[label=<template-parameter<BR/><BR/>template-parameter-list , template-parameter>];
    "template-parameter-list" -> tmplparl1;

    "requires-clause" -> "requires constraint-logical-or-expression";

    constlogorexp1[label=<constraint-logical-and-expression<BR/><BR/>constraint-logical-or-expression || constraint-logical-and-expression>];
    "constraint-logical-or-expression" -> constlogorexp1;

    constlogandexp1[label=<primary-expression<BR/><BR/>constraint-logical-and-expression &amp;&amp; primary-expression>];
    "constraint-logical-or-expression" -> constlogandexp1;



    # [temp.param] ------------------------------------------------------------------

    temppar1[label=<type-parameter<BR/><BR/>parameter-declaration>];
    "template-parameter" -> temppar1;

    typepar1[label=<type-parameter-key . . .<SUB>opt</SUB> identifier<SUB>opt</SUB><BR/><BR/>
type-parameter-key identifier<SUB>opt</SUB> = type-id<BR/><BR/>
type-constraint . . .<SUB>opt</SUB> identifier<SUB>opt</SUB><BR/><BR/>
type-constraint identifier<SUB>opt</SUB> = type-id<BR/><BR/>
template-head type-parameter-key . . .<SUB>opt</SUB> identifier<SUB>opt</SUB><BR/><BR/>
template-head type-parameter-key identifier<SUB>opt</SUB> = id-expression>];
    "type-parameter" -> typepar1;

    "type-parameter-key" -> "class";
    "type-parameter-key" -> "typename";

    tpcstr1[label=<nested-name-specifier<SUB>opt</SUB> concept-name<BR/><BR/>nested-name-specifier<SUB>opt</SUB> concept-name &lt; template-argument-list<SUB>opt</SUB> &gt;>];
    "type-constraint" -> tpcstr1;



    # [temp.names] ------------------------------------------------------------------

    smtempid1[label=<template-name &lt; template-argument-list<SUB>opt</SUB> &gt;>];
    "simple-template-id" -> smtempid1;

    tmpid1[label=<simple-template-id<BR/><BR/>operator-function-id &lt; template-argument-list<SUB>opt</SUB> &gt;<BR/><BR/>literal-operator-id &lt; template-argument-list<SUB>opt</SUB> &gt;>];
    "template-id" -> tmpid1;

    "template-name" -> "identifier";

    tmpargl1[label=<template-argument . . .<SUB>opt</SUB><BR/><BR/>template-argument-list , template-argument . . .<SUB>opt</SUB>>];
    "template-argument-list" -> tmpargl1;

    "template-argument" -> "constant-expression";
    "template-argument" -> "type-id";
    "template-argument" -> "id-expression";

    dedgd1[label=<explicit-specifier<SUB>opt</SUB> template-name ( parameter-declaration-clause ) -&gt; simple-template-id ;>];
    "deduction-guide" -> dedgd1;



    # [temp.concept] ------------------------------------------------------------------

    "concept-definition" -> "concept concept-name = constraint-expression ;";

    "concept-name" -> "identifier";

    explinstant1[label=<extern<SUB>opt</SUB> template declaration>];
    "explicit-instantiation" -> explinstant1;



    # [except.pre] ------------------------------------------------------------------

    "try-block" -> "try compound-statement handler-seq";

    functrblk1[label=<try ctor-initializer<SUB>opt</SUB> compound-statement handler-seq>];
    "function-try-block" -> functrblk1;

    hndseq1[label=<handler handler-seq<SUB>opt</SUB>>];
    "handler-seq" -> hndseq1;

    "handler" -> "catch ( exception-declaration ) compound-statement";

    excpdecl1[label=<attribute-specifier-seq<SUB>opt</SUB> type-specifier-seq declarator<BR/><BR/>attribute-specifier-seq<SUB>opt</SUB> type-specifier-seq abstract-declarator<SUB>opt</SUB><BR/><BR/>. . .>];
    "exception-declaration" -> excpdecl1;

    "noexcept-specifier" -> "noexcept ( constant-expression )";
    "noexcept-specifier" -> "noexcept";



    # [cpp.pre] ------------------------------------------------------------------
}
